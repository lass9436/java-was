package codesquad.database.csv;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class CsvStatement implements Statement {

	@Override
	public boolean execute(String sql) throws SQLException {
		String lowerSql = sql.trim().toLowerCase();
		if (lowerSql.startsWith("create table")) {
			executeCreateTable(sql);
			return true;
		} else if (lowerSql.startsWith("select")) {
			return executeQuery(sql) != null;
		} else if (lowerSql.startsWith("insert")) {
			return executeUpdate(sql) > 0;
		}
		throw new IllegalArgumentException("Unsupported SQL: " + sql);
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		return null;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {

	}

	@Override
	public int getFetchDirection() throws SQLException {
		return 0;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {

	}

	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return 0;
	}

	@Override
	public void addBatch(String sql) throws SQLException {

	}

	@Override
	public void clearBatch() throws SQLException {

	}

	@Override
	public int[] executeBatch() throws SQLException {
		return new int[0];
	}

	@Override
	public Connection getConnection() throws SQLException {
		return null;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return null;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		return 0;
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return false;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return false;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {

	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void closeOnCompletion() throws SQLException {

	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	private void executeCreateTable(String sql) throws SQLException {
		String tableName = extractTableNameFromCreate(sql);
		String filePath = System.getProperty("user.home") + "/csv/" + tableName + ".csv";

		File file = new File(filePath);
		file.getParentFile().mkdirs();  // 디렉토리 생성

		try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
			// 정규식을 사용하여 전체 컬럼 부분을 추출
			String columnsPart = sql.substring(sql.indexOf('(') + 1, sql.lastIndexOf(')')).trim();
			String[] columns = columnsPart.split(
				",(?=(?:[^\\(\\)]|\\([^\\(\\)]*\\))*$)"); // 쉼표를 기준으로 split하되 괄호 안의 쉼표는 제외
			List<String> columnNames = new ArrayList<>();
			for (String column : columns) {
				column = column.trim();
				if (column.toLowerCase().startsWith("primary") ||
					column.toLowerCase().startsWith("foreign") ||
					column.toLowerCase().startsWith("constraint")) {
					continue;
				}
				String columnName = column.split("\\s+")[0];
				columnNames.add(columnName);
			}
			writer.write(String.join(",", columnNames));
			writer.newLine();
		} catch (IOException e) {
			throw new SQLException("Failed to create CSV file.", e);
		}
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		String tableName = extractTableNameFromSelect(sql);
		String filePath = System.getProperty("user.home") + "/csv/" + tableName + ".csv";
		List<String[]> data = readCsv(filePath);

		//return new CsvResultSet(data);
		return null;
	}

	public int nextId(String filePath) throws SQLException {
		try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
			String header = reader.readLine();
			if (header == null) {
				return 1; // 파일이 비어 있는 경우 ID는 1로 시작
			}

			String[] columns = header.split(",");
			if (!columns[0].trim().equalsIgnoreCase("id")) {
				return -1; // 첫 번째 컬럼이 id가 아닌 경우 -1 반환
			}

			String lastRow = null;
			String currentRow;
			while ((currentRow = reader.readLine()) != null) {
				lastRow = currentRow;
			}

			if (lastRow == null) {
				return 1; // 데이터가 없는 경우 ID는 1로 시작
			}

			String[] lastRowData = lastRow.split(",");
			int lastId = Integer.parseInt(lastRowData[0].trim());

			return lastId + 1; // 마지막 ID 값에 1을 더하여 반환
		} catch (IOException e) {
			throw new SQLException("Failed to read the CSV file.", e);
		} catch (NumberFormatException e) {
			throw new SQLException("Invalid ID format in the CSV file.", e);
		}
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		String tableName = extractTableNameFromInsert(sql);
		String filePath = System.getProperty("user.home") + "/csv/" + tableName + ".csv";

		File file = new File(filePath);
		if (!file.exists()) {
			throw new SQLException("Table " + tableName + " does not exist.");
		}

		int nextId = nextId(filePath);

		try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
			if (nextId != -1) {
				writer.write(nextId + ",");
			}
			// 정규식을 사용하여 컬럼 이름과 값을 추출
			Pattern pattern = Pattern.compile("INSERT INTO\\s+(\\w+)\\s*\\(([^)]+)\\)\\s*VALUES\\s*\\(([^)]+)\\);?",
				Pattern.CASE_INSENSITIVE);
			Matcher matcher = pattern.matcher(sql);
			if (!matcher.find()) {
				throw new SQLException("Invalid SQL format.");
			}

			String columnsPart = matcher.group(2).trim();
			String valuesPart = matcher.group(3).trim();

			String[] columns = columnsPart.split("\\s*,\\s*");
			String[] values = parseValues(valuesPart);

			if (columns.length != values.length) {
				throw new SQLException("Column count does not match value count.");
			}

			writer.write(String.join(",", values));
			writer.newLine();

			return 1; // 1개의 행이 삽입되었음을 반환
		} catch (IOException e) {
			throw new SQLException("Failed to write to CSV file.", e);
		}
	}

	private String[] parseValues(String valuesPart) {
		List<String> values = new ArrayList<>();
		StringBuilder current = new StringBuilder();
		boolean inQuotes = false;

		for (char c : valuesPart.toCharArray()) {
			if (c == '\'' && (current.length() == 0 || current.charAt(current.length() - 1) != '\\')) {
				inQuotes = !inQuotes;
			} else if (c == ',' && !inQuotes) {
				values.add(current.toString().trim().replaceAll("^'|'$", "").replace("''", "'"));
				current.setLength(0);
			} else {
				current.append(c);
			}
		}
		values.add(current.toString().trim().replaceAll("^'|'$", "").replace("''", "'")); // 마지막 값 추가

		return values.toArray(new String[0]);
	}

	private String extractTableNameFromCreate(String sql) {
		return sql.split(" ")[2].trim();
	}

	private String extractTableNameFromInsert(String sql) {
		return sql.split(" ")[2].trim();
	}

	private String extractTableNameFromSelect(String sql) {
		return sql.split("from")[1].trim().split(" ")[0];
	}

	private List<String[]> readCsv(String filePath) throws SQLException {
		List<String[]> data = new ArrayList<>();
		try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
			String line;
			while ((line = reader.readLine()) != null) {
				data.add(line.split(","));
			}
		} catch (IOException e) {
			throw new SQLException("Failed to read CSV file.", e);
		}
		return data;
	}

	@Override
	public void close() throws SQLException {
		// Statement 종료 작업 필요 없음
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {

	}

	@Override
	public int getMaxRows() throws SQLException {
		return 0;
	}

	@Override
	public void setMaxRows(int max) throws SQLException {

	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {

	}

	@Override
	public int getQueryTimeout() throws SQLException {
		return 0;
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {

	}

	@Override
	public void cancel() throws SQLException {

	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {

	}

	@Override
	public void setCursorName(String name) throws SQLException {

	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	// 기타 필요하지 않은 메서드들은 생략합니다.
}
